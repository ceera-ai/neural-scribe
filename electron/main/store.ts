import Store from 'electron-store'

export interface FormattedVersion {
  id: string
  text: string
  timestamp: number
  sourceVersion: 'original' | string // 'original' or version id it was reformatted from
  customInstructions?: string // Custom instructions used for this reformat (if any)
}

export interface TranscriptionRecord {
  id: string
  text: string // The primary text (most recent formatted if available, otherwise original)
  originalText?: string // Raw transcription before formatting
  formattedText?: string // Legacy: first formatted version (kept for backward compatibility)
  formattedVersions?: FormattedVersion[] // Array of all formatted versions
  wasFormatted?: boolean // Whether formatting was applied
  title?: string // Short title/summary generated by formatter
  timestamp: number
  wordCount: number
  duration: number // Recording duration in seconds
}

export interface WordReplacement {
  id: string
  from: string
  to: string
  caseSensitive: boolean
  wholeWord: boolean
  enabled: boolean
}

export interface VoiceCommandTrigger {
  id: string
  phrase: string
  command: 'send' | 'clear' | 'cancel'
  enabled: boolean
  isCustom: boolean // true if user-added, false if built-in
}

export interface AppSettings {
  apiKey: string
  selectedMicrophoneId: string | null
  selectedTerminalId: string | null
  pasteHotkey: string
  recordHotkey: string
  recordWithFormattingHotkey: string
  submitAfterPaste: boolean
  replacementsEnabled: boolean
  voiceCommandsEnabled: boolean
  // Prompt formatting settings
  promptFormattingEnabled: boolean
  promptFormattingInstructions: string // Custom instructions (empty = use default)
  promptFormattingModel: 'sonnet' | 'opus' | 'haiku'
  // History settings
  historyLimit: number // 0 = no limit, otherwise max items to keep
}

// Gamification types
export interface UserStats {
  totalWordsTranscribed: number
  totalRecordingTimeMs: number
  totalSessions: number
  currentStreak: number
  longestStreak: number
  lastActiveDate: string // YYYY-MM-DD
  firstSessionDate: string // YYYY-MM-DD
}

export interface LevelSystem {
  currentXP: number
  level: number
  rank: string
  xpToNextLevel: number
  xpForCurrentLevel: number
  totalXPForNextLevel: number
}

export interface UnlockedAchievement {
  unlockedAt: number // Timestamp - NEVER regenerate
  xpAwarded: number
}

export interface GamificationData {
  version: string
  stats: UserStats
  level: LevelSystem
  achievements: {
    unlocked: Record<string, UnlockedAchievement>
  }
  metadata: {
    lastSaved: number
    totalSaves: number
    backupCount: number
  }
}

interface StoreSchema {
  settings: AppSettings
  history: TranscriptionRecord[]
  replacements: WordReplacement[]
  voiceCommandTriggers: VoiceCommandTrigger[]
  gamification: GamificationData
}

// Default gamification data
const defaultGamificationData: GamificationData = {
  version: '2.0',
  stats: {
    totalWordsTranscribed: 0,
    totalRecordingTimeMs: 0,
    totalSessions: 0,
    currentStreak: 0,
    longestStreak: 0,
    lastActiveDate: '',
    firstSessionDate: new Date().toISOString().split('T')[0],
  },
  level: {
    currentXP: 0,
    level: 1,
    rank: 'Initiate',
    xpToNextLevel: 100,
    xpForCurrentLevel: 0,
    totalXPForNextLevel: 100,
  },
  achievements: {
    unlocked: {},
  },
  metadata: {
    lastSaved: Date.now(),
    totalSaves: 0,
    backupCount: 0,
  },
}

// Default voice command triggers
const defaultVoiceCommandTriggers: VoiceCommandTrigger[] = [
  // Send commands
  { id: 'send-1', phrase: 'send it', command: 'send', enabled: true, isCustom: false },
  { id: 'send-2', phrase: 'send this', command: 'send', enabled: true, isCustom: false },
  { id: 'send-3', phrase: 'paste it', command: 'send', enabled: true, isCustom: false },
  { id: 'send-4', phrase: 'paste this', command: 'send', enabled: true, isCustom: false },
  { id: 'send-5', phrase: 'submit', command: 'send', enabled: true, isCustom: false },
  { id: 'send-6', phrase: 'go ahead', command: 'send', enabled: false, isCustom: false },
  { id: 'send-7', phrase: 'execute', command: 'send', enabled: false, isCustom: false },
  // Clear commands
  { id: 'clear-1', phrase: 'clear it', command: 'clear', enabled: true, isCustom: false },
  { id: 'clear-2', phrase: 'clear this', command: 'clear', enabled: true, isCustom: false },
  { id: 'clear-3', phrase: 'start over', command: 'clear', enabled: true, isCustom: false },
  // Cancel commands
  { id: 'cancel-1', phrase: 'cancel', command: 'cancel', enabled: true, isCustom: false },
  { id: 'cancel-2', phrase: 'never mind', command: 'cancel', enabled: true, isCustom: false },
  { id: 'cancel-3', phrase: 'stop', command: 'cancel', enabled: false, isCustom: false },
]

const defaults: StoreSchema = {
  settings: {
    apiKey: '',
    selectedMicrophoneId: null,
    selectedTerminalId: null,
    pasteHotkey: 'CommandOrControl+Shift+V',
    recordHotkey: 'CommandOrControl+Shift+R',
    recordWithFormattingHotkey: 'CommandOrControl+Shift+F',
    submitAfterPaste: true,
    replacementsEnabled: true,
    voiceCommandsEnabled: true,
    promptFormattingEnabled: true,
    promptFormattingInstructions: '', // Empty = use default instructions
    promptFormattingModel: 'sonnet',
    historyLimit: 500, // Default to 500 items, 0 = no limit
  },
  history: [],
  replacements: [],
  voiceCommandTriggers: defaultVoiceCommandTriggers,
  gamification: defaultGamificationData,
}

export const store = new Store<StoreSchema>({
  defaults,
  encryptionKey: 'elevenlabs-transcription-secure-key',
})

// Settings helpers
export function getSettings(): AppSettings {
  return store.get('settings')
}

export function setSettings(settings: Partial<AppSettings>): void {
  const current = store.get('settings')
  store.set('settings', { ...current, ...settings })
}

export function getApiKey(): string {
  return store.get('settings.apiKey') || ''
}

export function setApiKey(apiKey: string): void {
  store.set('settings.apiKey', apiKey)
}

// History helpers
export function getHistory(): TranscriptionRecord[] {
  return store.get('history')
}

export function getHistoryLimit(): number {
  return store.get('settings.historyLimit') ?? 500
}

export function saveTranscription(record: TranscriptionRecord): void {
  const history = store.get('history')
  // Check if this is an update to an existing record
  const existingIndex = history.findIndex((r) => r.id === record.id)
  let updated: TranscriptionRecord[]
  if (existingIndex >= 0) {
    // Update existing record in place
    updated = [...history]
    updated[existingIndex] = record
  } else {
    // Add new record at the beginning
    const limit = getHistoryLimit()
    const newHistory = [record, ...history]
    // Apply limit only if it's greater than 0 (0 = no limit)
    updated = limit > 0 ? newHistory.slice(0, limit) : newHistory
  }
  store.set('history', updated)
}

export function deleteTranscription(id: string): void {
  const history = store.get('history')
  store.set(
    'history',
    history.filter((r) => r.id !== id)
  )
}

export function clearHistory(): void {
  store.set('history', [])
}

export function getLastTranscription(): TranscriptionRecord | null {
  const history = store.get('history')
  return history.length > 0 ? history[0] : null
}

export function getHistoryStats(): {
  totalRecords: number
  totalWords: number
  totalDuration: number
  formattedCount: number
  averageWordCount: number
  averageDuration: number
} {
  const history = getHistory()

  const totalRecords = history.length
  const totalWords = history.reduce((sum, r) => sum + r.wordCount, 0)
  const totalDuration = history.reduce((sum, r) => sum + r.duration, 0)
  const formattedCount = history.filter((r) => r.wasFormatted).length

  return {
    totalRecords,
    totalWords,
    totalDuration,
    formattedCount,
    averageWordCount: totalRecords > 0 ? totalWords / totalRecords : 0,
    averageDuration: totalRecords > 0 ? totalDuration / totalRecords : 0,
  }
}

// Replacement helpers
export function getReplacements(): WordReplacement[] {
  return store.get('replacements') || []
}

export function addReplacement(replacement: WordReplacement): void {
  const replacements = store.get('replacements') || []
  store.set('replacements', [...replacements, replacement])
}

export function updateReplacement(id: string, updates: Partial<WordReplacement>): void {
  const replacements = store.get('replacements') || []
  store.set(
    'replacements',
    replacements.map((r) => (r.id === id ? { ...r, ...updates } : r))
  )
}

export function deleteReplacement(id: string): void {
  const replacements = store.get('replacements') || []
  store.set(
    'replacements',
    replacements.filter((r) => r.id !== id)
  )
}

export function applyReplacements(text: string): string {
  const replacements = store.get('replacements') || []
  let result = text

  for (const replacement of replacements) {
    if (!replacement.enabled) continue

    let pattern: RegExp
    const flags = replacement.caseSensitive ? 'g' : 'gi'

    if (replacement.wholeWord) {
      // Match whole words only using word boundaries
      pattern = new RegExp(`\\b${escapeRegex(replacement.from)}\\b`, flags)
    } else {
      pattern = new RegExp(escapeRegex(replacement.from), flags)
    }

    result = result.replace(pattern, replacement.to)
  }

  return result
}

// Helper to escape special regex characters
function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

// Voice command trigger helpers
export function getVoiceCommandTriggers(): VoiceCommandTrigger[] {
  const triggers = store.get('voiceCommandTriggers')
  // If no triggers exist (first run or reset), return defaults
  if (!triggers || triggers.length === 0) {
    store.set('voiceCommandTriggers', defaultVoiceCommandTriggers)
    return defaultVoiceCommandTriggers
  }
  return triggers
}

export function updateVoiceCommandTrigger(id: string, updates: Partial<VoiceCommandTrigger>): void {
  const triggers = store.get('voiceCommandTriggers') || []
  store.set(
    'voiceCommandTriggers',
    triggers.map((t) => (t.id === id ? { ...t, ...updates } : t))
  )
}

export function addVoiceCommandTrigger(trigger: VoiceCommandTrigger): void {
  const triggers = store.get('voiceCommandTriggers') || []
  store.set('voiceCommandTriggers', [...triggers, trigger])
}

export function deleteVoiceCommandTrigger(id: string): void {
  const triggers = store.get('voiceCommandTriggers') || []
  store.set(
    'voiceCommandTriggers',
    triggers.filter((t) => t.id !== id)
  )
}

export function resetVoiceCommandTriggers(): void {
  store.set('voiceCommandTriggers', defaultVoiceCommandTriggers)
}

// Get enabled triggers grouped by command type
export function getEnabledVoiceCommands(): { send: string[]; clear: string[]; cancel: string[] } {
  const triggers = getVoiceCommandTriggers()
  return {
    send: triggers.filter((t) => t.command === 'send' && t.enabled).map((t) => t.phrase),
    clear: triggers.filter((t) => t.command === 'clear' && t.enabled).map((t) => t.phrase),
    cancel: triggers.filter((t) => t.command === 'cancel' && t.enabled).map((t) => t.phrase),
  }
}

// Prompt formatting helpers
export function getPromptFormattingSettings(): {
  enabled: boolean
  instructions: string
  model: 'sonnet' | 'opus' | 'haiku'
} {
  const settings = getSettings()
  return {
    enabled: settings.promptFormattingEnabled ?? true,
    instructions: settings.promptFormattingInstructions ?? '',
    model: settings.promptFormattingModel ?? 'sonnet',
  }
}

export function setPromptFormattingEnabled(enabled: boolean): void {
  setSettings({ promptFormattingEnabled: enabled })
}

export function setPromptFormattingInstructions(instructions: string): void {
  setSettings({ promptFormattingInstructions: instructions })
}

export function setPromptFormattingModel(model: 'sonnet' | 'opus' | 'haiku'): void {
  setSettings({ promptFormattingModel: model })
}

// Paste settings helpers
export function getSubmitAfterPaste(): boolean {
  return getSettings().submitAfterPaste ?? true
}

export function setSubmitAfterPaste(submit: boolean): void {
  setSettings({ submitAfterPaste: submit })
}

// Gamification helpers
export function getGamificationData(): GamificationData {
  return store.get('gamification', defaultGamificationData)
}

export function saveGamificationData(data: Partial<GamificationData>): void {
  const current = getGamificationData()
  const updated: GamificationData = {
    ...current,
    ...data,
    metadata: {
      ...current.metadata,
      ...(data.metadata || {}),
      lastSaved: Date.now(),
      totalSaves: current.metadata.totalSaves + 1,
    },
  }

  store.set('gamification', updated)

  // TODO: Create backup every 10 saves
  // if (updated.metadata.totalSaves % 10 === 0) {
  //   createBackup(updated);
  // }
}

// Helper functions for XP and level calculations
function calculateLevelFromXP(xp: number, baseXP = 100, growthRate = 1.5): number {
  let level = 1
  let xpRequired = 0
  while (xp >= xpRequired + Math.floor(baseXP * Math.pow(growthRate, level - 1))) {
    xpRequired += Math.floor(baseXP * Math.pow(growthRate, level - 1))
    level++
  }
  return level
}

function calculateXPForLevel(level: number, baseXP = 100, growthRate = 1.5): number {
  if (level <= 1) return 0
  let total = 0
  for (let i = 1; i < level; i++) {
    total += Math.floor(baseXP * Math.pow(growthRate, i - 1))
  }
  return total
}

function getRankForLevel(level: number): { minLevel: number; name: string; icon: string } {
  const ranks = [
    { minLevel: 1, name: 'Initiate', icon: 'ðŸŒ±' },
    { minLevel: 5, name: 'Apprentice', icon: 'ðŸ“' },
    { minLevel: 10, name: 'Scribe', icon: 'âœï¸' },
    { minLevel: 15, name: 'Transcriber', icon: 'ðŸŽ™ï¸' },
    { minLevel: 20, name: 'Linguist', icon: 'ðŸ—£ï¸' },
    { minLevel: 30, name: 'Oracle', icon: 'ðŸ”®' },
    { minLevel: 40, name: 'Cyberscribe', icon: 'âš¡' },
    { minLevel: 50, name: 'Neural Sage', icon: 'ðŸ§ ' },
    { minLevel: 75, name: 'Transcendent', icon: 'âœ¨' },
    { minLevel: 100, name: 'Singularity', icon: 'ðŸŒŒ' },
  ]
  const sorted = [...ranks].sort((a, b) => b.minLevel - a.minLevel)
  return sorted.find((r) => level >= r.minLevel) || ranks[0]
}

export function recordGamificationSession(
  words: number,
  durationMs: number
): {
  xpGained: number
  newAchievements: string[]
  leveledUp: boolean
  oldLevel: number
  newLevel: number
} {
  const data = getGamificationData()

  // Update stats
  const updatedStats: UserStats = {
    ...data.stats,
    totalWordsTranscribed: data.stats.totalWordsTranscribed + words,
    totalRecordingTimeMs: data.stats.totalRecordingTimeMs + durationMs,
    totalSessions: data.stats.totalSessions + 1,
  }

  // Update streak
  const today = new Date().toISOString().split('T')[0]
  if (data.stats.lastActiveDate !== today) {
    if (data.stats.lastActiveDate) {
      const lastDate = new Date(data.stats.lastActiveDate)
      const todayDate = new Date(today)
      const diffDays = Math.floor(
        (todayDate.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24)
      )

      if (diffDays === 1) {
        // Consecutive day
        updatedStats.currentStreak = data.stats.currentStreak + 1
        updatedStats.longestStreak = Math.max(updatedStats.currentStreak, data.stats.longestStreak)
      } else if (diffDays > 1) {
        // Streak broken
        updatedStats.currentStreak = 1
      }
    } else {
      // First session ever
      updatedStats.currentStreak = 1
      updatedStats.longestStreak = Math.max(1, data.stats.longestStreak)
    }

    updatedStats.lastActiveDate = today
  }

  // Calculate XP (from strategy doc)
  const wordXP = words * 1
  const timeXP = Math.floor(durationMs / 60000) * 10
  const sessionXP = 25
  const totalXP = wordXP + timeXP + sessionXP

  const oldLevel = data.level.level
  const oldXP = data.level.currentXP
  const newXP = oldXP + totalXP

  // Check achievements (will be implemented by importing from gamification.ts)
  const newAchievements: string[] = []
  // TODO: Import ACHIEVEMENTS and check which ones should unlock
  // This will be done in the IPC handler which has access to the achievements

  // Update level
  const newLevel = calculateLevelFromXP(newXP)
  const leveledUp = newLevel > oldLevel
  const rank = getRankForLevel(newLevel)

  const xpForCurrentLevel = calculateXPForLevel(newLevel)
  const totalXPForNextLevel = calculateXPForLevel(newLevel + 1)
  const xpToNextLevel = totalXPForNextLevel - newXP

  const updatedLevel: LevelSystem = {
    currentXP: newXP,
    level: newLevel,
    rank: rank.name,
    xpToNextLevel,
    xpForCurrentLevel,
    totalXPForNextLevel,
  }

  // Save everything
  saveGamificationData({
    stats: updatedStats,
    level: updatedLevel,
  })

  return {
    xpGained: totalXP,
    newAchievements,
    leveledUp,
    oldLevel,
    newLevel,
  }
}

export function unlockGamificationAchievement(achievementId: string, xpReward: number): void {
  const data = getGamificationData()

  // Don't unlock if already unlocked
  if (data.achievements.unlocked[achievementId]) {
    return
  }

  // Add to unlocked achievements with timestamp
  const unlocked: UnlockedAchievement = {
    unlockedAt: Date.now(), // This is set ONCE and never regenerated
    xpAwarded: xpReward,
  }

  data.achievements.unlocked[achievementId] = unlocked

  // Award XP
  data.level.currentXP += xpReward

  // Recalculate level
  const newLevel = calculateLevelFromXP(data.level.currentXP)
  if (newLevel > data.level.level) {
    const rank = getRankForLevel(newLevel)
    const xpForCurrentLevel = calculateXPForLevel(newLevel)
    const totalXPForNextLevel = calculateXPForLevel(newLevel + 1)
    const xpToNextLevel = totalXPForNextLevel - data.level.currentXP

    data.level = {
      currentXP: data.level.currentXP,
      level: newLevel,
      rank: rank.name,
      xpToNextLevel,
      xpForCurrentLevel,
      totalXPForNextLevel,
    }
  } else {
    // Just update XP, recalculate xpToNextLevel
    const xpForCurrentLevel = calculateXPForLevel(data.level.level)
    const totalXPForNextLevel = calculateXPForLevel(data.level.level + 1)
    const xpToNextLevel = totalXPForNextLevel - data.level.currentXP

    data.level.xpToNextLevel = xpToNextLevel
    data.level.xpForCurrentLevel = xpForCurrentLevel
  }

  saveGamificationData(data)
}

export function checkDailyLoginBonus(): {
  bonusAwarded: boolean
  xpGained: number
  streakUpdated: boolean
  currentStreak: number
} {
  const data = getGamificationData()
  const today = new Date().toISOString().split('T')[0]

  if (data.stats.lastActiveDate === today) {
    // Already logged in today
    return {
      bonusAwarded: false,
      xpGained: 0,
      streakUpdated: false,
      currentStreak: data.stats.currentStreak,
    }
  }

  // Award daily bonus
  const dailyBonus = 50
  const updatedStats = { ...data.stats }

  if (data.stats.lastActiveDate) {
    const lastDate = new Date(data.stats.lastActiveDate)
    const todayDate = new Date(today)
    const diffDays = Math.floor((todayDate.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24))

    if (diffDays === 1) {
      updatedStats.currentStreak = data.stats.currentStreak + 1
      updatedStats.longestStreak = Math.max(updatedStats.currentStreak, data.stats.longestStreak)
    } else if (diffDays > 1) {
      updatedStats.currentStreak = 1
    }
  } else {
    updatedStats.currentStreak = 1
    updatedStats.longestStreak = Math.max(1, data.stats.longestStreak)
  }

  updatedStats.lastActiveDate = today

  // Add XP
  const newXP = data.level.currentXP + dailyBonus
  const newLevel = calculateLevelFromXP(newXP)
  const rank = getRankForLevel(newLevel)
  const xpForCurrentLevel = calculateXPForLevel(newLevel)
  const totalXPForNextLevel = calculateXPForLevel(newLevel + 1)
  const xpToNextLevel = totalXPForNextLevel - newXP

  saveGamificationData({
    stats: updatedStats,
    level: {
      currentXP: newXP,
      level: newLevel,
      rank: rank.name,
      xpToNextLevel,
      xpForCurrentLevel,
      totalXPForNextLevel,
    },
  })

  return {
    bonusAwarded: true,
    xpGained: dailyBonus,
    streakUpdated: true,
    currentStreak: updatedStats.currentStreak,
  }
}

export function resetGamificationProgress(): void {
  store.set('gamification', defaultGamificationData)
}
